package ar.edu.itba.cep.evaluations_service.domain.helpers;

import ar.edu.itba.cep.evaluations_service.models.*;
import ar.edu.itba.cep.executor.models.Language;
import com.github.javafaker.Faker;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.core.context.SecurityContextHolder;

import java.time.Duration;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.*;
import java.util.concurrent.TimeUnit;
import java.util.function.IntFunction;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

import static org.mockito.Mockito.when;

/**
 * Helper class for testing.
 */
public final class TestHelper {

    /**
     * Private constructor to avoid instantiation.
     */
    private TestHelper() {
    }


    /**
     * Amount of days (in a non leap year).
     */
    private static final int DAYS_IN_A_YEAR = 365;

    /**
     * Indicates how many elements must have the created {@link String} {@link List}s used for testing
     * (i.e to be used as inputs and expected outputs).
     */
    private static final int LISTS_SIZE = 10;

    // ================================================================================================================
    // Creation helpers
    // ================================================================================================================

    /**
     * Creates a {@link Stream} of random length, applying the given {@code creator} to seed the stream.
     *
     * @param creator An {@link IntFunction} that takes an integer seed and creates a value for the {@link Stream}.
     * @param <T>     Concrete type of object in the {@link Stream}.
     * @return The created {@link Stream}.
     * @implNote This method uses {@link IntStream#range(int, int)} to generate the {@link Stream}.
     * The {@code creator} will consume those ints generated by the said method.
     */
    public static <T> Stream<T> randomLengthStream(final IntFunction<T> creator) {
        final var length = (int) Faker.instance().number().numberBetween(0L, LISTS_SIZE);
        return IntStream.range(0, length).mapToObj(creator);
    }


    // ================================================================================================================
    // Valid values
    // ================================================================================================================

    /**
     * @return A valid {@link Exam} id.
     */
    public static long validExamId() {
        return Faker.instance().number().numberBetween(1L, Long.MAX_VALUE);
    }

    /**
     * @return A valid {@link Exam} description.
     */
    public static String validExamDescription() {
        return Faker.instance()
                .lorem()
                .characters(ValidationConstants.DESCRIPTION_MIN_LENGTH, ValidationConstants.DESCRIPTION_MAX_LENGTH);
    }

    /**
     * @return A valid {@link Exam} starting moment {@link LocalDateTime}.
     */
    public static LocalDateTime validExamStartingMoment() {
        final var nextDayInstant = Instant.now().plus(Duration.ofDays(1));
        return Faker.instance()
                .date()
                .future(DAYS_IN_A_YEAR, TimeUnit.DAYS, Date.from(nextDayInstant))
                .toInstant()
                .atZone(ZoneId.systemDefault())
                .toLocalDateTime()
                ;
    }

    /**
     * @return A valid {@link Exam} {@link Duration}.
     */
    public static Duration validExamDuration() {
        return Duration.ofMinutes(Faker.instance().number().numberBetween(15L, 240L));
    }

    /**
     * @return A random username.
     */
    public static String validOwner() {
        return Faker.instance().name().username();
    }

    /**
     * @return A valid {@link Exercise} id.
     */
    public static long validExerciseId() {
        return Faker.instance().number().numberBetween(1L, Long.MAX_VALUE);
    }

    /**
     * @return A valid {@link Exercise} question.
     */
    public static String validExerciseQuestion() {
        // There is no such max value for questions, but it is needed for creating a value with Faker
        final var maxLength = Short.MAX_VALUE;
        return Faker.instance()
                .lorem()
                .characters(ValidationConstants.QUESTION_MIN_LENGTH, maxLength);
    }

    /**
     * @return A valid random {@link Language}.
     */
    public static Language validLanguage() {
        final var languages = Language.values();
        final var randomIndex = (int) Faker.instance().number().numberBetween(0L, languages.length);
        return languages[randomIndex];
    }

    /**
     * @return A random valid solution template.
     */
    public static String validSolutionTemplate() {
        return validExerciseSolutionAnswer();
    }

    /**
     * @return A random valid awarded score.
     */
    public static int validAwardedScore() {
        return (int) Faker.instance().number().numberBetween(1L, Integer.MAX_VALUE);
    }

    /**
     * @return A valid {@link TestCase} id.
     */
    public static long validTestCaseId() {
        return Faker.instance().number().numberBetween(1L, Long.MAX_VALUE);
    }

    /**
     * @return A random {@link TestCase.Visibility}.
     */
    public static TestCase.Visibility validTestCaseVisibility() {
        final var visibilities = TestCase.Visibility.values();
        final var randomIndex = (int) Faker.instance().number().numberBetween(0L, visibilities.length);
        return visibilities[randomIndex];
    }

    /**
     * @return A random valid timeout.
     */
    public static Long validTestCaseTimeout() {
        final List<Long> validValues = new LinkedList<>();
        validValues.add(Faker.instance().number().numberBetween(1, Long.MAX_VALUE));
        validValues.add(null);
        final var index = (int) Faker.instance().number().numberBetween(0L, validValues.size());
        return validValues.get(index);
    }

    /**
     * Creates a valid {@link List} of {@link String} to be used as inputs or expected outputs.
     *
     * @return A valid {@link List}.
     */
    public static List<String> validTestCaseList() {
        return Faker.instance().lorem().words(LISTS_SIZE);
    }

    /**
     * @return A random answer.
     */
    public static String validExerciseSolutionAnswer() {
        final List<String> values = new LinkedList<>();
        values.add(null);
        values.add("");
        values.add(Faker.instance().lorem().characters());
        final var index = (int) Faker.instance().number().numberBetween(0L, values.size());
        return values.get(index);
    }

    /**
     * @return A random compiler flags.
     */
    public static String validCompilerFlags() {
        final List<String> values = new LinkedList<>();
        values.add(null);
        values.add("");
        values.add(Faker.instance().lorem().characters());
        final var index = (int) Faker.instance().number().numberBetween(0L, values.size());
        return values.get(index);
    }

    /**
     * @return A valid {@link ExamSolutionSubmission} id.
     */
    public static long validExamSolutionSubmissionId() {
        return Faker.instance().number().numberBetween(1L, Long.MAX_VALUE);
    }

    /**
     * @return A random valid score.
     */
    public static int validScore() {
        return (int) Faker.instance().number().numberBetween(1L, Integer.MAX_VALUE);
    }

    /**
     * @return A valid {@link ExerciseSolution} id.
     */
    public static long validExerciseSolutionId() {
        return Faker.instance().number().numberBetween(1L, Long.MAX_VALUE);
    }

    /**
     * @return An {@link ExerciseSolutionResult.Result} other than the {@link ExerciseSolutionResult.Result#APPROVED}.
     */
    public static ExerciseSolutionResult.Result notApprovedResult() {
        final var results = Arrays.stream(ExerciseSolutionResult.Result.values())
                .filter(r -> r != ExerciseSolutionResult.Result.APPROVED)
                .collect(Collectors.toList());
        final var index = (int) Faker.instance().number().numberBetween(0L, results.size());
        return results.get(index);
    }

    /**
     * @return A valid {@link ExerciseSolution} exit code.
     */
    public static int validNonZeroExerciseSolutionExitCode() {
        final var negatives = Faker.instance().number().numberBetween(Integer.MIN_VALUE, -1);
        final var positives = Faker.instance().number().numberBetween(1, Integer.MAX_VALUE);
        final var values = List.of(negatives, positives);
        final var index = (int) Faker.instance().number().numberBetween(0L, values.size());
        return values.get(index);
    }

    /**
     * Creates a valid {@link List} of {@link String} to be used as stdout or stderr when processing an execution.
     *
     * @return A valid {@link List}.
     */
    public static List<String> validExerciseSolutionResultList() {
        return Faker.instance()
                .lorem()
                .words(LISTS_SIZE);
    }


    // ================================================================================================================
    // Invalid values
    // ================================================================================================================

    /**
     * @return An invalid {@link Exam} description.
     */
    public static String invalidExamDescription() {
        final var possibleValues = new LinkedList<String>();
        // Add a null value
        possibleValues.add(null);
        // Add a long description
        possibleValues.add(Faker.instance()
                .lorem()
                .fixedString(ValidationConstants.DESCRIPTION_MAX_LENGTH + 1));
        // Add a short description
        if (ValidationConstants.DESCRIPTION_MIN_LENGTH > 0) {
            possibleValues.add(
                    Faker.instance()
                            .lorem()
                            .fixedString(ValidationConstants.DESCRIPTION_MIN_LENGTH - 1)
            );
        }
        final var index = (int) Faker.instance().number().numberBetween(0L, possibleValues.size());
        return possibleValues.get(index);
    }


    /**
     * @return An invalid {@link Exam} {@link LocalDateTime} starting moment.
     */
    public static LocalDateTime invalidExamStartingAt() {
        final var possibleValues = new LinkedList<LocalDateTime>();
        // Add a null value
        possibleValues.add(null);
        // Add a past date
        final var previousDayInstant = Instant.now().minus(Duration.ofDays(1));
        possibleValues.add(
                Faker.instance()
                        .date()
                        .past(DAYS_IN_A_YEAR, TimeUnit.DAYS, Date.from(previousDayInstant))
                        .toInstant()
                        .atZone(ZoneId.systemDefault())
                        .toLocalDateTime()
        );
        final var index = (int) Faker.instance().number().numberBetween(0L, possibleValues.size());
        return possibleValues.get(index);
    }

    /**
     * @return An invalid {@link Exam} duration.
     */
    public static Duration invalidExamDuration() {
        final List<Duration> invalidValues = new LinkedList<>();
        invalidValues.add(null);
        invalidValues.add(Duration.ZERO);
        invalidValues.add(Duration.ofMinutes(Faker.instance().number().numberBetween(Short.MIN_VALUE, 0L)));
        final var index = (int) Faker.instance().number().numberBetween(0L, invalidValues.size());
        return invalidValues.get(index);
    }

    /**
     * @return An invalid owner.
     */
    public static String invalidOwner() {
        final List<String> invalidValues = new LinkedList<>();
        invalidValues.add(null);
        invalidValues.add("");
        invalidValues.add(" \t\n");
        final var index = (int) Faker.instance().number().numberBetween(0L, invalidValues.size());
        return invalidValues.get(index);
    }

    /**
     * @return An invalid {@link Exercise} question.
     */
    public static String invalidExerciseQuestion() {
        final var possibleValues = new LinkedList<String>();
        // Add a null value
        possibleValues.add(null);
        // Add a short description
        if (ValidationConstants.QUESTION_MIN_LENGTH > 0) {
            possibleValues.add(
                    Faker.instance()
                            .lorem()
                            .fixedString(ValidationConstants.QUESTION_MIN_LENGTH - 1)
            );
        }
        final var index = (int) Faker.instance().number().numberBetween(0L, possibleValues.size());
        return possibleValues.get(index);
    }

    /**
     * @return An invalid awarded score. Is invalid because it is not positive.
     */
    public static int nonPositiveAwardedScore() {
        return (int) Faker.instance().number().numberBetween(Integer.MIN_VALUE, 1L);
    }

    /**
     * @return An invalid {@link Language}.
     */
    public static Language invalidLanguage() {
        return null;
    }

    /**
     * @return An invalid {@link TestCase.Visibility}.
     */
    public static TestCase.Visibility invalidTestCaseVisibility() {
        return null;
    }

    /**
     * @return An invalid {@link TestCase} output.
     */
    public static long invalidTestCaseTimeout() {
        return Faker.instance().number().numberBetween(Long.MIN_VALUE, 1);
    }

    /**
     * @return An invalid {@link List} of {@link String} for {@link TestCase}.
     */
    public static List<String> invalidTestCaseList() {
        final var listWithNulls = Stream.concat(
                Faker.instance().lorem().words(LISTS_SIZE - 1).stream(),
                Stream.of((String) null)
        ).collect(Collectors.toList());
        Collections.shuffle(listWithNulls); // Perform shuffling to be sure that check is performed in all the list

        return listWithNulls;
    }


    /**
     * Sets up the given {@code securityContext} using the given {@code authentication}
     * whose {@code principal} is the given one.
     *
     * @param principal       The principal.
     * @param authentication  The {@link Authentication} set in the {@link SecurityContext}.
     * @param securityContext The {@link SecurityContext} being configured.
     */
    public static void setupSecurityContext(
            final String principal,
            final Authentication authentication,
            final SecurityContext securityContext) {
        // Set the security context
        when(authentication.getPrincipal()).thenReturn(principal);
        when(securityContext.getAuthentication()).thenReturn(authentication);
        SecurityContextHolder.setContext(securityContext);
    }

    /**
     * Clears the {@link SecurityContextHolder}.
     */
    public static void clearSecurityContext() {
        SecurityContextHolder.clearContext();
    }
}
